This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
Dockerfile
package.json
src/config/database.sql
src/config/db.ts
src/config/setupDatabase.ts
src/controllers/authController.ts
src/controllers/passwordController.ts
src/index.ts
src/middlewares/authMiddleware.ts
src/models/userModel.ts
src/routes/authRoutes.ts
src/services/emailService.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Dockerfile">
FROM node:16-alpine

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

RUN npm run build

EXPOSE 3001

CMD ["npm", "start"]
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "nodemon src/index.ts",
    "build": "tsc",
    "setup-db": "ts-node src/config/setupDatabase.ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@types/express": "^4.17.21",
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "nodemailer": "^7.0.3",
    "pg": "^8.16.0"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/cors": "^2.8.18",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/nodemailer": "^6.4.17",
    "@types/pg": "^8.15.2",
    "nodemon": "^3.1.10",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="src/config/database.sql">
-- Tabelas necessárias para o sistema de manutenção de ativos

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE assets (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    location VARCHAR(100),
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE maintenance_types (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    is_default BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE maintenance_records (
    id SERIAL PRIMARY KEY,
    asset_id INTEGER REFERENCES assets(id) ON DELETE CASCADE,
    maintenance_type_id INTEGER REFERENCES maintenance_types(id) ON DELETE SET NULL,
    date_performed DATE NOT NULL,
    notes TEXT,
    cost DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE maintenance_schedules (
    id SERIAL PRIMARY KEY,
    asset_id INTEGER REFERENCES assets(id) ON DELETE CASCADE,
    maintenance_type_id INTEGER REFERENCES maintenance_types(id) ON DELETE SET NULL,
    based_on_record_id INTEGER REFERENCES maintenance_records(id) ON DELETE SET NULL,
    scheduled_date DATE NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    frequency_type VARCHAR(20) NOT NULL,
    frequency_value INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE password_reset_tokens (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    token VARCHAR(100) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Índices para melhorar performance
CREATE INDEX idx_assets_user_id ON assets(user_id);
CREATE INDEX idx_maintenance_records_asset_id ON maintenance_records(asset_id);
CREATE INDEX idx_maintenance_schedules_asset_id ON maintenance_schedules(asset_id);
CREATE INDEX idx_maintenance_schedules_status ON maintenance_schedules(status);
</file>

<file path="src/config/db.ts">
import { Pool } from 'pg';
import dotenv from 'dotenv';

dotenv.config();

// Em vez de criar o pool imediatamente, crie uma função para obter o pool
let pool: Pool;

function getPool() {
  if (!pool) {
    pool = new Pool({
      user: process.env.DB_USER || 'postgres',
      host: process.env.DB_HOST || 'localhost',
      database: process.env.DB_NAME || 'maintenance_system',
      password: process.env.DB_PASSWORD || 'postgres',
      port: parseInt(process.env.DB_PORT || '5432'),
    });
  }
  return pool;
}

export default {
  query: async (text: string, params?: any[]) => {
    const client = await getPool().connect();
    try {
      return await client.query(text, params);
    } finally {
      client.release();
    }
  },
  getClient: () => getPool().connect(),
};
</file>

<file path="src/config/setupDatabase.ts">
import { Pool } from 'pg';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';

dotenv.config();

async function setupDatabase() {
  // Aguardar um pouco para garantir que o PostgreSQL está pronto
  console.log('Aguardando PostgreSQL inicializar...');
  await new Promise(resolve => setTimeout(resolve, 3000));

  // Criar um novo pool específico para a configuração
  const pool = new Pool({
    user: process.env.DB_USER || 'postgres',
    host: process.env.DB_HOST || 'localhost',
    database: process.env.DB_NAME || 'maintenance_system',
    password: process.env.DB_PASSWORD || 'postgres',
    port: parseInt(process.env.DB_PORT || '5432'),
  });

  try {
    // Testar conexão primeiro
    await pool.query('SELECT NOW()');
    console.log('Conexão com PostgreSQL estabelecida!');

    // Ler o arquivo SQL
    const sql = fs.readFileSync(
      path.join(__dirname, 'database.sql'),
      'utf8'
    );

    // Executar o script SQL
    await pool.query(sql);
    console.log('Banco de dados inicializado com sucesso!');
  } catch (error) {
    console.error('Erro ao inicializar o banco de dados:', error);
    process.exit(1);
  } finally {
    // Fechar a conexão
    await pool.end();
  }
}

// Executar a função
setupDatabase();
</file>

<file path="src/controllers/authController.ts">
import { Request, Response } from 'express';
import * as jwt from 'jsonwebtoken';
import userModel from '../models/userModel';
import dotenv from 'dotenv';

dotenv.config();

// Tipagem correta para o payload
interface JwtPayload {
  id: number;
  name: string;
  email: string;
}

// Função para gerar token JWT
function generateToken(payload: JwtPayload): string {
  const secret = process.env.JWT_SECRET || 'default_secret';
  return jwt.sign(payload, secret, {
    expiresIn: process.env.JWT_EXPIRES_IN || '1d',
  } as jwt.SignOptions);
}

const authController = {
  async register(req: Request, res: Response): Promise<Response> {
    try {
      const { name, email, password } = req.body;

      if (!name || !email || !password) {
        return res.status(400).json({ message: 'Todos os campos são obrigatórios' });
      }

      // Verificar se o email já está em uso
      const existingUser = await userModel.findByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: 'Email já está em uso' });
      }

      // Criar o usuário
      const user = await userModel.create({ name, email, password });

      // Remover o password antes de retornar
      const userWithoutPassword = {
        id: user.id,
        name: user.name,
        email: user.email,
        created_at: user.created_at,
        updated_at: user.updated_at
      };

      return res.status(201).json({
        user: userWithoutPassword,
        token: generateToken({ id: user.id, name: user.name, email: user.email }),
      });
    } catch (error) {
      console.error('Erro ao registrar usuário:', error);
      return res.status(500).json({ message: 'Erro interno do servidor' });
    }
  },

  async login(req: Request, res: Response): Promise<Response> {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        return res.status(400).json({ message: 'Email e senha são obrigatórios' });
      }

      // Buscar usuário pelo email
      const user = await userModel.findByEmail(email);
      if (!user) {
        return res.status(401).json({ message: 'Credenciais inválidas' });
      }

      // Verificar senha
      const passwordMatch = await userModel.validatePassword(password, user.password_hash);
      if (!passwordMatch) {
        return res.status(401).json({ message: 'Credenciais inválidas' });
      }

      return res.json({
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
        },
        token: generateToken({ id: user.id, name: user.name, email: user.email }),
      });
    } catch (error) {
      console.error('Erro ao fazer login:', error);
      return res.status(500).json({ message: 'Erro interno do servidor' });
    }
  },

  async getProfile(req: Request, res: Response): Promise<Response> {
    try {
      const userId = req.user?.id;

      if (!userId) {
        return res.status(401).json({ message: 'Usuário não autenticado' });
      }

      const user = await userModel.findById(userId);

      if (!user) {
        return res.status(404).json({ message: 'Usuário não encontrado' });
      }

      return res.json({ user });
    } catch (error) {
      console.error('Erro ao obter perfil:', error);
      return res.status(500).json({ message: 'Erro interno do servidor' });
    }
  },
};

export default authController;
</file>

<file path="src/controllers/passwordController.ts">
import { Request, Response } from 'express';
import crypto from 'crypto';
import userModel from '../models/userModel';
import db from '../config/db';
import { sendEmail } from '../services/emailService';
import dotenv from 'dotenv';

dotenv.config();

const passwordController = {
  async forgotPassword(req: Request, res: Response): Promise<Response> {
    try {
      const { email } = req.body;

      if (!email) {
        return res.status(400).json({ message: 'Email é obrigatório' });
      }

      const user = await userModel.findByEmail(email);
      if (!user) {
        // Por segurança, não informamos se o email existe ou não
        return res.status(200).json({ message: 'Se um usuário com esse email existir, enviaremos instruções de recuperação' });
      }

      // Gerar token
      const token = crypto.randomBytes(20).toString('hex');
      const now = new Date();
      const expireDate = new Date(now);
      expireDate.setHours(now.getHours() + 1); // Expira em 1 hora

      // Salvar o token no banco
      await db.query(
        'INSERT INTO password_reset_tokens (user_id, token, expires_at) VALUES ($1, $2, $3)',
        [user.id, token, expireDate]
      );

      // Enviar email com o token
      const resetUrl = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password/${token}`;

      await sendEmail({
        to: email,
        subject: 'Recuperação de senha',
        text: `Você solicitou a recuperação de senha. Use o link a seguir para definir uma nova senha: ${resetUrl}`,
        html: `
          <p>Você solicitou a recuperação de senha.</p>
          <p>Use o link a seguir para definir uma nova senha:</p>
          <a href="${resetUrl}">${resetUrl}</a>
          <p>Se você não solicitou isso, ignore este email.</p>
        `
      });

      return res.status(200).json({ message: 'Email de recuperação enviado' });
    } catch (error) {
      console.error('Erro ao solicitar recuperação de senha:', error);
      return res.status(500).json({ message: 'Erro interno do servidor' });
    }
  },

  async resetPassword(req: Request, res: Response): Promise<Response> {
    try {
      const { token, password } = req.body;

      if (!token || !password) {
        return res.status(400).json({ message: 'Token e nova senha são obrigatórios' });
      }

      // Verificar se o token existe e está válido
      const result = await db.query(
        'SELECT * FROM password_reset_tokens WHERE token = $1 AND expires_at > CURRENT_TIMESTAMP',
        [token]
      );

      if (result.rows.length === 0) {
        return res.status(400).json({ message: 'Token inválido ou expirado' });
      }

      const resetToken = result.rows[0];
      const userId = resetToken.user_id;

      // Atualizar a senha
      await userModel.updatePasswordHash(userId, password);

      // Invalidar o token usado
      await db.query('DELETE FROM password_reset_tokens WHERE id = $1', [resetToken.id]);

      return res.status(200).json({ message: 'Senha atualizada com sucesso' });
    } catch (error) {
      console.error('Erro ao redefinir senha:', error);
      return res.status(500).json({ message: 'Erro interno do servidor' });
    }
  }
};

export default passwordController;
</file>

<file path="src/index.ts">
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import authRoutes from './routes/authRoutes';
import db from './config/db';

dotenv.config();

const app = express();
const port = process.env.PORT || 3001;

// Middlewares
app.use(cors());
app.use(express.json());

// Rotas
app.use('/api/auth', authRoutes);

// Rota de teste
app.get('/', (req, res) => {
  res.json({ message: 'API do Sistema de Manutenção de Ativos' });
});

// Rota de health check
app.get('/health', async (req, res) => {
  try {
    const dbConnected = await db.testConnection();
    res.json({
      status: 'ok',
      database: dbConnected ? 'connected' : 'disconnected',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      database: 'disconnected',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Função para aguardar o banco de dados estar pronto
async function waitForDatabase(maxRetries = 30, delay = 1000) {
  console.log('Aguardando conexão com o banco de dados...');

  for (let i = 0; i < maxRetries; i++) {
    try {
      const connected = await db.testConnection();
      if (connected) {
        console.log('✅ Conexão com o banco de dados estabelecida!');
        return true;
      }
    } catch (error) {
      console.log(`Tentativa ${i + 1}/${maxRetries}: Banco de dados ainda não está pronto...`);
    }

    await new Promise(resolve => setTimeout(resolve, delay));
  }

  throw new Error('Não foi possível conectar ao banco de dados');
}

// Iniciar servidor apenas após o banco estar pronto
async function startServer() {
  try {
    // Aguardar o banco de dados apenas se estivermos em produção ou Docker
    if (process.env.NODE_ENV === 'production' || process.env.DB_HOST === 'postgres') {
      await waitForDatabase();
    }

    app.listen(port, () => {
      console.log(`🚀 Servidor rodando na porta ${port}`);
      console.log(`📍 Ambiente: ${process.env.NODE_ENV || 'development'}`);
      console.log(`📍 Database: ${process.env.DB_HOST || 'localhost'}:${process.env.DB_PORT || '5432'}`);
    });
  } catch (error) {
    console.error('❌ Erro ao iniciar o servidor:', error);
    process.exit(1);
  }
}

// Iniciar o servidor
startServer();
</file>

<file path="src/middlewares/authMiddleware.ts">
import { Request, Response, NextFunction } from 'express';
import * as jwt from 'jsonwebtoken';
import dotenv from 'dotenv';

dotenv.config();

interface TokenPayload {
  id: number;
  name: string;
  email: string;
}

declare global {
  namespace Express {
    interface Request {
      user?: TokenPayload;
    }
  }
}

export default function authMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): void | Response {
  const authHeader = req.headers.authorization;

  if (!authHeader) {
    return res.status(401).json({ message: 'Token não fornecido' });
  }

  const parts = authHeader.split(' ');

  if (parts.length !== 2) {
    return res.status(401).json({ message: 'Token com formato inválido' });
  }

  const [scheme, token] = parts;

  if (!/^Bearer$/i.test(scheme)) {
    return res.status(401).json({ message: 'Token mal formatado' });
  }

  try {
    // Usando a tipagem correta para o secret
    const secret: jwt.Secret = process.env.JWT_SECRET || 'default_secret';
    const decoded = jwt.verify(token, secret) as TokenPayload;

    req.user = decoded;

    next();
  } catch (err) {
    return res.status(401).json({ message: 'Token inválido' });
  }
}
</file>

<file path="src/models/userModel.ts">
// backend/src/models/userModel.ts
import db from '../config/db';
import bcrypt from 'bcrypt';

interface User {
  id?: number;
  name: string;
  email: string;
  password?: string;
  password_hash?: string;
  created_at?: Date;
  updated_at?: Date;
}

const userModel = {
  async findByEmail(email: string) {
    const result = await db.query(
      'SELECT * FROM users WHERE email = $1',
      [email]
    );
    return result.rows[0];
  },

  async findById(id: number) {
    const result = await db.query(
      'SELECT id, name, email, created_at, updated_at FROM users WHERE id = $1',
      [id]
    );
    return result.rows[0];
  },

  async create(user: User) {
    const salt = await bcrypt.genSalt(10);
    const password_hash = await bcrypt.hash(user.password!, salt);

    const result = await db.query(
      'INSERT INTO users (name, email, password_hash) VALUES ($1, $2, $3) RETURNING id, name, email, created_at, updated_at',
      [user.name, user.email, password_hash]
    );

    return result.rows[0];
  },

  async validatePassword(plainPassword: string, hashedPassword: string) {
    return await bcrypt.compare(plainPassword, hashedPassword);
  },

  async updatePasswordHash(userId: number, newPassword: string) {
    const salt = await bcrypt.genSalt(10);
    const password_hash = await bcrypt.hash(newPassword, salt);

    const result = await db.query(
      'UPDATE users SET password_hash = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 RETURNING id',
      [password_hash, userId]
    );

    return result.rows[0];
  }
};

export default userModel;
</file>

<file path="src/routes/authRoutes.ts">
// backend/src/routes/authRoutes.ts
import { Router } from 'express';
import authController from '../controllers/authController';
import passwordController from '../controllers/passwordController';
import authMiddleware from '../middlewares/authMiddleware';

const router = Router();

// Rotas públicas
router.post('/register', (req, res) => authController.register(req, res));
router.post('/login', (req, res) => authController.login(req, res));
router.post('/forgot-password', (req, res) => passwordController.forgotPassword(req, res));
router.post('/reset-password', (req, res) => passwordController.resetPassword(req, res));

// Rotas protegidas
router.get('/profile', authMiddleware, (req, res) => authController.getProfile(req, res));

export default router;
</file>

<file path="src/services/emailService.ts">
// backend/src/services/emailService.ts
import nodemailer from 'nodemailer';
import dotenv from 'dotenv';

dotenv.config();

interface EmailOptions {
  to: string;
  subject: string;
  text: string;
  html: string;
}

export async function sendEmail(options: EmailOptions) {
  // Criar transportador
  const transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: parseInt(process.env.SMTP_PORT || '587'),
    secure: false, // true para 465, false para outras portas
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASS,
    },
  });

  // Enviar email
  const info = await transporter.sendMail({
    from: `"Sistema de Manutenção" <${process.env.SMTP_USER}>`,
    to: options.to,
    subject: options.subject,
    text: options.text,
    html: options.html,
  });

  console.log('Email enviado: %s', info.messageId);

  return info;
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es6",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "**/*.test.ts"
  ]
}
</file>

</files>
